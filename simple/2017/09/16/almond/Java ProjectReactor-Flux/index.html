<!DOCTYPE html>
<html>
<head><link rel=manifest href=/manifest.json><meta name="generator" content="Hexo 3.8.0"><link rel="manifest" href="/manifest.json">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  
  <title>Java ProjectReactor框架之Flux篇 | Kurome</title>
  <meta name="description" content="A minimal hexo theme.">
  <meta name="keywords" content="">
  <meta name="HandheldFriendly" content="True">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring5现处在第四个预发布版，正式版将要发布了，它带来的一大特性就是响应式框架Spring WebFlux。默认使用ProjectReactor框架。因此。本文通过ProjectReactor中的Flux，来学习使用该框架，以及了解其传递的思想。    本文基于Reactor3.1 rc1     Reactor官方地址http://projectreactor.io/，官方文档写的十分详细">
<meta name="keywords" content="WebFlux,Reactor,Reactive">
<meta property="og:type" content="article">
<meta property="og:title" content="Java ProjectReactor框架之Flux篇">
<meta property="og:url" content="https://jiangtj.gitlab.io/2017/09/16/almond/Java ProjectReactor-Flux/index.html">
<meta property="og:site_name" content="Kurome">
<meta property="og:description" content="Spring5现处在第四个预发布版，正式版将要发布了，它带来的一大特性就是响应式框架Spring WebFlux。默认使用ProjectReactor框架。因此。本文通过ProjectReactor中的Flux，来学习使用该框架，以及了解其传递的思想。    本文基于Reactor3.1 rc1     Reactor官方地址http://projectreactor.io/，官方文档写的十分详细">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/combinelatest.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/defer.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/firstemitting.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/fromarray.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/generate.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/interval.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/justn.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/merge.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/never.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/switchonnext.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/using.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/zip.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concatmap.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png">
<meta property="og:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/groupby.png">
<meta property="og:updated_time" content="2018-11-02T05:59:55.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java ProjectReactor框架之Flux篇">
<meta name="twitter:description" content="Spring5现处在第四个预发布版，正式版将要发布了，它带来的一大特性就是响应式框架Spring WebFlux。默认使用ProjectReactor框架。因此。本文通过ProjectReactor中的Flux，来学习使用该框架，以及了解其传递的思想。    本文基于Reactor3.1 rc1     Reactor官方地址http://projectreactor.io/，官方文档写的十分详细">
<meta name="twitter:image" content="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/combinelatest.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  <script type="text/javascript">
    var HexoConfig = {
      root: '/simple/',
      search: {
        enabled: 'true'
      }
    };
  </script>

	<!-- <script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script> -->
  <link rel="stylesheet" href="/simple/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  

</head>
</html>
<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/simple/">
		  
			  <span id="site-title">Kurome</span>
			
			<span id="site-desc">
			  若白驹过隙，忽然而已
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/simple/" class="nav-home nav">
          Home
        </a>
      
        <a href="/simple/about" class="nav-about nav">
          About
        </a>
      
        <a href="/simple/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      <article id="post-almond/Java ProjectReactor-Flux" class="post article white-box article-type-post" itemscope="" itemprop="blogPost">
	<h2 class="title">
  	<a href="/simple/2017/09/16/almond/Java ProjectReactor-Flux/">
    	Java ProjectReactor框架之Flux篇
    </a>
  </h2>
	<time>
	  9月 17, 2017
	</time>
	<section class="content">
  	<div class="article-entry" itemprop="articleBody">
    	<p>Spring5现处在第四个预发布版，正式版将要发布了，它带来的一大特性就是响应式框架Spring WebFlux。默认使用ProjectReactor框架。因此。本文通过ProjectReactor中的Flux，来学习使用该框架，以及了解其传递的思想。   </p>
<p>本文基于Reactor3.1 rc1    </p>
<p>Reactor官方地址<a href="http://projectreactor.io/" target="_blank" rel="noopener">http://projectreactor.io/</a>，官方文档写的十分详细，如果您有不错的英文能力，建议直接阅读官方文档。  </p>
<a id="more"></a>
<h3 id="Spring-WebFlux-实践"><a href="#Spring-WebFlux-实践" class="headerlink" title="Spring WebFlux 实践"></a>Spring WebFlux 实践</h3><p>首先，为大家带来一个使用了ProjectReactor的例子，该例子使用Spring Boot 2.0.0.BUILD-SNAPSHOT。因Spring Boot推荐默认配置（约定）优先，可以极大减少大量的重复的模版化代码，简化搭建过程。   </p>
<p><em>Spring Boot 2.0.0稳定版还未出，不过也快了，目前处在第四个里程碑版本。</em>   </p>
<h4 id="step1-搭建环境"><a href="#step1-搭建环境" class="headerlink" title="step1:搭建环境"></a>step1:搭建环境</h4><p>spring boot部分工具如idea提供了可视化操作，选择reactive-web模块即可（你也可以多选一些你需要的模块），如果没有可视化的工具，也可访问官网的开始页面<a href="https://start.spring.io/" target="_blank" rel="noopener">https://start.spring.io/</a>，或者在pom中引入一下模块（web开发主流仍是maven，所以未采用gradle）<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.projectreactor<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>reactor-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="step2-编写处理类"><a href="#step2-编写处理类" class="headerlink" title="step2:编写处理类"></a>step2:编写处理类</h4><p>编写一个简单的处理类，TestHandler<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@NonNullApi</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;ServerResponse&gt; <span class="title">data</span><span class="params">(ServerRequest request)</span></span>&#123;</span><br><span class="line">        Mono&lt;String&gt; mono =  Mono.justOrEmpty(request.queryParam(<span class="string">"data"</span>))</span><br><span class="line">                .defaultIfEmpty(<span class="string">"this is null"</span>)</span><br><span class="line">                .map(it -&gt; it.concat(<span class="string">"! from server webflux!"</span>));</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.ok().body(mono,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="step3-编写路由"><a href="#step3-编写路由" class="headerlink" title="step3:编写路由"></a>step3:编写路由</h4><p>spring webflux也提供了函数试的路由配置，如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RoutingConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RouterFunction&lt;ServerResponse&gt; <span class="title">testRouterFunction</span><span class="params">(TestHandler handle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RouterFunctions.route(GET(<span class="string">"/test"</span>).and(accept(APPLICATION_JSON)), handle::data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="step4-测试，验证"><a href="#step4-测试，验证" class="headerlink" title="step4:测试，验证"></a>step4:测试，验证</h4><p>当浏览器输入<a href="http://localhost:8080/test，得到结果：this" target="_blank" rel="noopener">http://localhost:8080/test，得到结果：this</a> is null! from server webflux!<br>当浏览器输入<a href="http://localhost:8688/test?data=hi，得到结果：hi" target="_blank" rel="noopener">http://localhost:8688/test?data=hi，得到结果：hi</a>! from server webflux!</p>
<p><em>我的webflux项目地址：<a href="https://github.com/JiangTJ/circuasset" target="_blank" rel="noopener">GitHub</a></em></p>
<h3 id="深入学习"><a href="#深入学习" class="headerlink" title="深入学习"></a>深入学习</h3><blockquote>
<p>看过实践后，你会发现有大量的使用Flux和Mono，它们是什么呢？</p>
</blockquote>
<p>Flux<t> 继承自 Publisher<t> ，用于代表拥有 0 到 n 元素的流，相对于 Mono<t> (其包含0-1个元素) 更加复杂。所以弄懂了Flux，其实也已经对Mono熟悉了。  </t></t></t></p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>Flux一般通过静态方法构造，所以先看看它的静态方法。 </p>
<h4 id="combineLatest"><a href="#combineLatest" class="headerlink" title="combineLatest"></a>combineLatest</h4><p>public static &lt;T,V&gt; Flux<v> combineLatest(Function&lt;Object[],V&gt; combinator, Publisher&lt;? extends T&gt;… sources)<br>构建一个Flux，混合由多个的发布者发布最新事件.</v></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/combinelatest.png" alt="">  </p>
<p>Type Parameters:<br>T - 表示发布者的事件类型<br>V - 被混合者混合后的类型<br>Parameters:<br>sources - 发布者，提供事件<br>combinator - 混合者，接受最新的事件，处理并传递给下游。<br>Returns:  一个以Flux为基础的混合流<br><em>不同的参数方法很多，这里都只展示一个。</em>  </p>
<h4 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h4><p>public static <t> Flux<t> concat(Publisher&lt;? extends T&gt;… sources)<br>用于连接一个流。与combineLatest不同的是，concat都是在前一个流完成后在连接新的流。而combineLatest，则哪个事件最先到的，哪个先处理。  </t></t></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png" alt="">  </p>
<p>Type Parameters:<br>T - 事件的类型<br>Parameters:<br>sources - 一系列的发布者<br>Returns:  一个新的Flux连接了所有的发布者，并传递给下游    </p>
<h4 id="concatDelayError"><a href="#concatDelayError" class="headerlink" title="concatDelayError"></a>concatDelayError</h4><p>拥有与concat类似的方法，不同的是，遇到错误不提前拦截，而是等到最后发布的事件处理完成后</p>
<h4 id="create-push"><a href="#create-push" class="headerlink" title="create,push"></a>create,push</h4><p>public static <t> Flux<t> create(Consumer&lt;? super FluxSink<t>&gt; emitter)<br>通过FluxSink API，以同步或者异步方式创建Flux。<br>例如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Flux.&lt;String&gt;create(emitter -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    ActionListener al = e -&gt; &#123;</span><br><span class="line">        emitter.next(textField.getText());</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// without cleanup support:</span></span><br><span class="line"></span><br><span class="line">    button.addActionListener(al);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// with cleanup support:</span></span><br><span class="line"></span><br><span class="line">    button.addActionListener(al);</span><br><span class="line">    emitter.onDispose(() -&gt; &#123;</span><br><span class="line">        button.removeListener(al);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></t></t></t></p>
<p>这是非常有用的，如果一个流，需要动态添加或者移除其他的多个事件，通过异步的api。而且，你将不必担心被取消和背压。<br><em>create(Consumer&lt;? super FluxSink<t>&gt; emitter, FluxSink.OverflowStrategy backpressure) 设置背压方式</t></em><br>push方法用处与使用方式与create几乎一致，它们唯一的区别在于CreateMode类型 create为PUSH_PULL，而push为PUSH_ONLY，从文档中也可以一个为多线程一个为单线程  </p>
<h5 id="backpressure-背压-概念的理解"><a href="#backpressure-背压-概念的理解" class="headerlink" title="backpressure(背压)概念的理解"></a>backpressure(背压)概念的理解</h5><p>这里，我摘自一位大神的话，背压是指在异步场景中，被观察者发送事件速度远快于观察者的处理速度的情况下，一种告诉上游的被观察者降低发送速度的策略。简而言之，背压是流速控制的一种策略。  </p>
<blockquote>
<p>更多的背压到<a href="http://www.jianshu.com/p/2c4799fa91a4" target="_blank" rel="noopener">http://www.jianshu.com/p/2c4799fa91a4</a>这里不多做介绍了    </p>
</blockquote>
<h4 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h4><p>public static <t> Flux<t> defer(Supplier&lt;? extends Publisher<t>&gt; supplier)<br>这个方法提供了一种惰性策略，发布者不会一开始发布消息，直到订阅者创建实例.<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/defer.png" alt=""><br>Type Parameters:<br>T - 发布者发布或订阅者接受的类型<br>Parameters:<br>supplier - 一个发布者的供应者，当订阅的时候回调<br>Returns: 一个惰性的Flux  </t></t></t></p>
<h4 id="empty"><a href="#empty" class="headerlink" title="empty"></a>empty</h4><p>public static <t> Flux<t> empty()<br>创建一个不含任何事件的流.</t></t></p>
<h4 id="error"><a href="#error" class="headerlink" title="error"></a>error</h4><p>public static <t> Flux<t> error(Throwable error)<br>返回一个带着立即终止标识和错误信息的流 </t></t></p>
<h4 id="first"><a href="#first" class="headerlink" title="first"></a>first</h4><p>public static <i> Flux<i> first(Publisher&lt;? extends I&gt;… sources)<br>挑选出第一个发布者，由其提供事件。能有效避免多个源的冲突。<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/firstemitting.png" alt="">  </i></i></p>
<h4 id="from"><a href="#from" class="headerlink" title="from"></a>from</h4><p>public static <t> Flux<t> from(Publisher&lt;? extends T&gt; source)<br>public static <t> Flux<t> fromIterable(Iterable&lt;? extends T&gt; it)<br>public static <t> Flux<t> fromStream(Stream&lt;? extends T&gt; s)<br>从一个发布者创建一个flux流  </t></t></t></t></t></t></p>
<h4 id="fromArray，fromIterable，fromStream"><a href="#fromArray，fromIterable，fromStream" class="headerlink" title="fromArray，fromIterable，fromStream"></a>fromArray，fromIterable，fromStream</h4><p>public static <t> Flux<t> fromArray(T[] array)<br>通过一个数组，或者一个可迭代的元素，或者一个流，创建flux流.  </t></t></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/fromarray.png" alt="">  </p>
<p>Type Parameters:<br>T - 数组的类型和Flux的类型<br>Parameters:<br>emmm.. - 数组,可迭代的元素,流<br>Returns: 新的flux流  </p>
<h4 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h4><p>public static <t> Flux<t> generate(Consumer&lt;SynchronousSink<t>&gt; generator)<br>Programmatically create a Flux by generating signals one-by-one via a consumer callback.  </t></t></t></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/generate.png" alt="">  </p>
<p>Type Parameters:<br>T - the value type emitted<br>Parameters:<br>generator - Consume the SynchronousSink provided per-subscriber by Reactor to generate a single signal on each pass.<br>Returns: a Flux<br>没看懂，好像是说，通过编程方式创建一个一对一的消费回调  </p>
<h4 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h4><p>public static Flux<long> interval(Duration period)<br>间隔一定的时间，发送事件。<br>Runs on the Schedulers.parallel() Scheduler.<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/interval.png" alt="">  </long></p>
<h4 id="just"><a href="#just" class="headerlink" title="just"></a>just</h4><p>public static <t> Flux<t> just(T… data)<br>创建一个包含一系列元素的flux流<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/justn.png" alt="">  </t></t></p>
<h4 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h4><p>public static <i> Flux<i> merge(Publisher&lt;? extends I&gt;… sources)<br>混合多个流，和combineLatest类似，但它要求是同类型的流合并，combineLatest需要提供合并方式<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/merge.png" alt=""> </i></i></p>
<h4 id="never"><a href="#never" class="headerlink" title="never"></a>never</h4><p>public static <t> Flux<t> never()<br>Create a Flux that will never signal any data, error or completion signal.  </t></t></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/never.png" alt="">  </p>
<p>Type Parameters:<br>T - the Subscriber type target<br>Returns:<br>a never completing Flux<br>看一看，不是很明白，该流的用处。 </p>
<h4 id="range"><a href="#range" class="headerlink" title="range"></a>range</h4><p>public static Flux<integer> range(int start, int count)<br>提供从start，到start + count的所有整数的flux流</integer></p>
<h4 id="switchOnNext"><a href="#switchOnNext" class="headerlink" title="switchOnNext"></a>switchOnNext</h4><p>public static <t> Flux<t> switchOnNext(Publisher&lt;? extends Publisher&lt;? extends T&gt;&gt; mergedPublishers)<br>从最新的发布者那里获取事件，如果有新的发布者加入，则改用新的发布者。<br>当最后一个发布者完成所有发布事件，并且没有发布者加入，则flux完成。<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/switchonnext.png" alt=""></t></t></p>
<h4 id="using"><a href="#using" class="headerlink" title="using"></a>using</h4><p>public static &lt;T,D&gt; Flux<t> using(Callable&lt;? extends D&gt; resourceSupplier, Function&lt;? super D,? extends Publisher&lt;? extends T&gt;&gt; sourceSupplier, Consumer&lt;? super D&gt; resourceCleanup)<br>Uses a resource, generated by a supplier for each individual Subscriber, while streaming the values from a Publisher derived from the same resource and makes sure the resource is released if the sequence terminates or the Subscriber cancels.<br>Eager resource cleanup happens just before the source termination and exceptions raised by the cleanup Consumer may override the terminal even.</t></p>
<p><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/using.png" alt=""></p>
<h4 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h4><p>public static &lt;I,O&gt; Flux<o> zip(Function&lt;? super Object[],? extends O&gt; combinator, Publisher&lt;? extends I&gt;… sources)<br>通过混合者，合并多个流成一个输出流，一一对应合并<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/zip.png" alt="">  </o></p>
<h4 id="…"><a href="#…" class="headerlink" title="…"></a>…</h4><p>看一下下面的api<br>public static &lt;T1,T2,T3,V&gt; Flux<v> combineLatest(Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3, Function&lt;Object[],V&gt; combinator)<br>public static &lt;T1,T2,T3,T4,V&gt; Flux<v> combineLatest(Publisher&lt;? extends T1&gt; source1, Publisher&lt;? extends T2&gt; source2, Publisher&lt;? extends T3&gt; source3, Publisher&lt;? extends T4&gt; source4, Function&lt;Object[],V&gt; combinator)<br>…<br>public static &lt;T1,T2&gt; Flux&lt;Tuple2&lt;T1,T2&gt;&gt; zip(Publisher&lt;? extends T1&gt; source1, lisher&lt;? extends T2&gt; source2)<br>public static &lt;T1,T2,T3&gt; Flux&lt;Tuple3&lt;T1,T2,T3&gt;&gt; zip(Publisher&lt;? extends T1&gt; source1, lisher&lt;? extends T2&gt; source2, lisher&lt;? extends T3&gt; source3)<br>…<br>ヽ(o_ _)o摔倒，我也是服了project reactor 官方。</v></v></p>
<h3 id="常用的实例方法"><a href="#常用的实例方法" class="headerlink" title="常用的实例方法"></a>常用的实例方法</h3><p>静态的方法介绍完了，但是实例方法比静态方法多太多，所以这里只举常用的几种介绍</p>
<h4 id="all-any-hasElement-hasElements"><a href="#all-any-hasElement-hasElements" class="headerlink" title="all,any,hasElement,hasElements"></a>all,any,hasElement,hasElements</h4><p>这几个方法调用，均返回包涵一个Boolean信号的Mono。</p>
<ul>
<li>all(Predicate&lt;? super T&gt; predicate)表示所有值均满足条件</li>
<li>any(Predicate&lt;? super T&gt; predicate)表示存在一个值满足条件</li>
<li>hasElement(T t)表示是否存在该值</li>
<li>hasElements()表示是否拥有一个或多个元素</li>
</ul>
<h4 id="as-compose"><a href="#as-compose" class="headerlink" title="as,compose"></a>as,compose</h4><p>public final </p><p> P as(Function&lt;? super Flux<t>,P&gt; transformer)<br>转化flux为一个目标类型。<br>官方例子：flux.as(Mono::from).subscribe()<br>将flux通过Mono.from函数转化为mono<br>public final <v> Flux<v> compose(Function&lt;? super Flux<t>,? extends Publisher<v>&gt; transformer)<br>compose与as的区别是转化类型做了限制，必须继承Publisher，同时compose是惰性的。在很多时候，写法上没有差别如flux.compose(Mono::from).subscribe()   </v></t></v></v></t></p>
<h4 id="blockFirst-blockLast"><a href="#blockFirst-blockLast" class="headerlink" title="blockFirst,blockLast"></a>blockFirst,blockLast</h4><p>阻塞至第一个或者最后一个值处理完成</p>
<h4 id="butter系列"><a href="#butter系列" class="headerlink" title="butter系列"></a>butter系列</h4><p>该系列实例方法很多，作用是将一系列元素，分成一组或者多组，该方法可用在按组批量操作上，例如，以时间间隔分组，批量添加数据。</p>
<h4 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h4><p>如其名缓存，相当于复制一份用于接下来的操作，而当前的流将会被缓存起来，用于之后的操作。</p>
<h4 id="cancelOn"><a href="#cancelOn" class="headerlink" title="cancelOn"></a>cancelOn</h4><p>public final Flux<t> cancelOn(Scheduler scheduler)<br>取消</t></p>
<h4 id="cast"><a href="#cast" class="headerlink" title="cast"></a>cast</h4><p>public final <e> Flux<e> cast(Class<e> clazz)<br>强转</e></e></e></p>
<h4 id="checkpoint"><a href="#checkpoint" class="headerlink" title="checkpoint"></a>checkpoint</h4><p>用于检测当前节点，流中是否存在错误</p>
<h4 id="collect系列"><a href="#collect系列" class="headerlink" title="collect系列"></a>collect系列</h4><p>该系列实例方法，用于收集所有的元素到特定类型，如list、map等<br>处理完成时返回Mono</p>
<h4 id="concatMap系列-flatMap系列"><a href="#concatMap系列-flatMap系列" class="headerlink" title="concatMap系列,flatMap系列"></a>concatMap系列,flatMap系列</h4><p>举例说明吧，[[1,2],[4,5],[6,7,8]] -&gt; [1,2,4,5,6,7,8]起这种转化作用<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concatmap.png" alt=""><br>flatMap系列一样  </p>
<h4 id="concatWith"><a href="#concatWith" class="headerlink" title="concatWith"></a>concatWith</h4><p>与concatMap不同，这是相加<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/concat.png" alt="">  </p>
<h4 id="defaultIfEmpty"><a href="#defaultIfEmpty" class="headerlink" title="defaultIfEmpty"></a>defaultIfEmpty</h4><p>public final Flux<t> defaultIfEmpty(T defaultV) 默认值  </t></p>
<h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p>public final Flux<t> distinct()<br>去重，相对与jdk8，多了下面两种方法<br>public final <v> Flux<t> distinct(Function&lt;? super T,? extends V&gt; keySelector)<br>public final &lt;V,C extends Collection&lt;? super V&gt;&gt; Flux<t> distinct(Function&lt;? super T,? extends V&gt; Supplier<c> distinctCollectionSupplier)<br>去除与V匹配的和第二个不怎么理解，，，这让我想到了filter  </c></t></t></v></t></p>
<h4 id="do系列"><a href="#do系列" class="headerlink" title="do系列"></a>do系列</h4><p>还系列有doOnNext,doOnError,doOnCancel等等，均表示完成后触发</p>
<h4 id="elementAt"><a href="#elementAt" class="headerlink" title="elementAt"></a>elementAt</h4><p>返回某一位置的值，类型为Mono<t>，可以设置默认值</t></p>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p>public final Flux<t> filter(Predicate&lt;? super T&gt; p)<br>过滤出满足条件的  </t></p>
<h4 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h4><p>public final <k> Flux&lt;GroupedFlux&lt;K,T&gt;&gt; groupBy(Function&lt;? super T,? extends K&gt; keyMapper)<br><img src="https://raw.githubusercontent.com/reactor/reactor-core/v3.1.0.RC1/src/docs/marble/groupby.png" alt=""><br>分组，根据提供的keyMapper</k></p>
<h4 id="mark"><a href="#mark" class="headerlink" title="mark"></a>mark</h4><p>标记一下，写到h接下来还有一些要写，暂时不写了，太累。。。先写会实践（实践提前放在开头，入门）  </p>
<p><em>未完待续</em></p>

  	</div>

	  <div class="article-tags tags">
		  
        <a class="tag-link" href="/simple/tags/Reactive/">Reactive</a><a class="tag-link" href="/simple/tags/Reactor/">Reactor</a><a class="tag-link" href="/simple/tags/WebFlux/">WebFlux</a>
      
	  </div>
	</section>
</article>




      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  
	<div class="search">
	  <form name="searchform" id="searchform" class="u-search-form">
	    <input type="text" id="searchinput" class="u-search-input" placeholder="Looking for something?">
	    <button type="submit" id="u-search-btn-submit" class="u-search-btn-submit">
	      <span class="icon icon-search"></span>
	    </button>
	  </form>
	</div>
	

	<div class="social-wrapper">
  	
      
        <a href="mailto:jiang.taojie@foxmail.com" class="social email" target="_blank" rel="external">
          <span class="icon icon-email"></span>
        </a>
      
        <a href="https://github.com/jiangtj" class="social github" target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">Kurome</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  



<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/simple/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/simple/js/search.js"></script>
<script src="/simple/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
<script>if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js?t=1544754478564')
    .then(function () {console.log('ServiceWorker Register Successfully.')})
    .catch(function (e) {console.error(e)});
}
</script></body>
</html>
